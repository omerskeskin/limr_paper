\section{Conclusion and Related Work}
In this work we have mechanised the semantics of local and global types, proved a correspondence between them,
and used this correspondence to prove safety, deadlock-freedom and liveness for the typed sessions in 
simple message-passing calculus. To our knowledge, our liveness result is the first mechanised
one of its kind, and is the most challenging of the theorems we formalised. Our implementation
illustrates some of the difficulties encountered when mechanising liveness properties in general.
These include the use of mixed inductive-coinductive reasoning and the absence of a clear general proof technique.
In particular, the induction on the tree context height used in \cref{theo-ctx-live}
requires some care to set up, and is not the most obvious way of implementing the proof in Rocq.
Our earlier unsuccesful attempts at that proof included one which proceeded by induction 
on the grafting (\cref{def:global-ctx}) of local type trees, which turned out to be a 
defective induction variable. Still, our work illustrates the power of parameterised
coinduction in the verification of liveness properties, and provides a framework
for the verification of further linear time properties on session types. 

\textbf{Related Work.} Examinations of liveness, also called \textit{lock-freedom}, guarantees of multiparty session types abound in literature, e.g. 
\cite{padovani_typing_2014,kobayashi_type_2002,LessIsMoreRevisited,LessIsMore,barbanera_partially_2023}.
Most of these papers use the definition liveness proposed by Padovani \cite{padovani}, 
which doesn't make the fairness assumptions that characterize the property \cite{francez_fairness_1986} explicit. 
Contrastingly, van Glabbeek et. al. \cite{fairnesslock} examine several notions of fairness and the liveness properties
induced by them, and devise a type system with flexible choices \cite{castellani_reversible_2019} that captures
the strongest of these properties, the one induced by the \textit{justness} \cite{fairness} assumption.
In their terminology, \cref{def-live-sess}
corresponds to liveness under strong fairness of transitions (ST), 
which is the weakest of the properties considered in that paper. They also show that their 
type system is complete i.e. every live process can be typed. We haven't presented any completeness results 
in this paper. Indeed, our type system is not complete for \cref{def-live-sess}, even if we restrict our attention to safe and race-free sessions. 
For example, the session described in \cite[Example 9]{fairnesslock}
is live but not typable by a context associated with a balanced global type in our system.
Fairness assumptions are also made explicit in recent work by Ciccone et. al \cite{ciccone_fair_2024,ciccone_2022-binary} 
which use generalized inference systems with coaxioms \cite{ancona_generalizing_2017} to characterize 
\textit{fair termination}, which is stronger than \cref{def-live-sess}, but enjoys good compositionality properties.

Mechanisation of session types in proof assistants is a relatively new effort. 
Our formalisation is built on recent work by Ekici et. al. \cite{srpaper} which uses a coinductive representation
of global and local types to prove subject reduction and progress. 
Their work uses a typing relation between global types and sessions while ours uses one 
between associated local type contexts and sessions. This necessiates the rewriting of
subject reduction and progress proofs in addition to the novel operational correspondence, safety and liveness
properties we have proved. Other recent results mechanised in Rocq include Ekici and Yoshida's \cite{ekici_completeness_2024}
work on the completeness of asynchronous subtyping, and Tirore's work \cite{tirore_thesis, tirore2025multiparty,tirore2023sound}
on projections and subject reduction for $\pi$-calculus. 

Castro-Perez et. al. \cite{castro2026synthetic} devise a multiparty session type system 
that dispenses with projections and local types by defining the typing relation directly on the LTS
specifying the global protocol, and formalise the results in Agda. Ciccone's PhD thesis \cite{ciccone2023concertogrossosessionsfair}
presents an Agda formalisation of fair termination for binary session types. 
Binary session types were also implemented in Agda by Thiemann \cite{thiemann2019} and in Idris by Brady\cite{brady_type-driven_2017}. Several implementations of
binary session types are also present for Haskell \cite{dardha2021,lindley2016embedding,pucella2008haskell}. 

Implementations of session types that are more geared towards practical verification include the 
Actris framework \cite{hinrichsen2019actris,jacobs2024deadlock} which enriches the 
seperation logic of Iris \cite{jung2018iris} with binary session types to certify deadlock-freedom.
In general, verification of liveness properties, with or without session types, in concurrent seperation logic is an active research area
that has produced tools such as TaDa \cite{gardner2021tada}, FOS \cite{lee2023fos} and LiLo \cite{lee2025lilo}
in the past few years. Further verification tools employing multiparty session types are 
Jacobs's Multiparty GV \cite{jacobs2024deadlock} based on the functional language of Wadler's GV \cite{wadler2012gv}, and Castro-Perez et. al's Zooid \cite{zooid},
which supports the extraction of certifiably safe and live protocols.

