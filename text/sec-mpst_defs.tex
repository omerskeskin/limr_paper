\section{The Type System}
We briefly recap the core definitions of local and global type trees, 
subtyping and projection from
\cite{SynchronousSubtyping}. We take an equirecursive approach and 
work directly on the possibly infinite local and global type trees 
obtained by unfolding the recursion
in guarded syntactic types, details of this approach
can be found in \cite{srpaper} and hence are omitted here.  
\label{sec:types}
\subsection{Local Type Trees}
We start by defining the sorts that will be used to type expressions, 
and local types that will be used to type single processes.
\begin{definition}[Sorts and Local Type Trees]
We define three atomic sorts: $\tint$, $\tbool$ and $\tnat$.
Local type trees are then defined coinductively with the following syntax: 
\begin{minipage}{0.45\textwidth}
\begin{align*}
    \T ::= \quad &\tend \\
     \SEP &\procinset{\prt{p}}{\ell_i(\S_i)}{\T_i}{i \in I} \\
     \SEP &\procoutset{\prt{p}}{\ell_i(\S_i)}{\T_i}{i \in I}
    \end{align*}  
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{tcb}{Rocq}
Inductive sort: Type :=
   | sbool: sort | sint : sort | snat : sort.
CoInductive ltt: Type :=
  | ltt_end : ltt
  | ltt_recv: part -> list (option(sort*ltt)) -> ltt
  | ltt_send: part -> list (option(sort*ltt)) -> ltt.
\end{tcb}  
\end{minipage}
\end{definition}
In the above definition, $\tend$ represents a role that has finished communicating.
$\ltsend{\prt{p}}{\ell_i(\S_i).\T}_{i \in I}$ denotes a role that may, from any $i \in I$, 
receive a value of sort $S_i$ with message label $\ell_i$ and continue with $\tlt_i$.
Similarly, $\ltrec{\prt{p}}{\ell_i(\S_i).\T_i}_{i \in I}$ represents a role that may choose
to send a value of sort $S_i$ with message label $\ell_i$ and continue with $\T_i$ for any $i \in I$.

In Rocq we represent the continuations using a \lstin{list} of \lstin{option} types. 
In a continuation \lstin{gcs : list (option(sort*ltt))}, index \lstin{k} (using zero-indexing) being equal to 
\lstin{Some (s_k, T_k)} means that $\ell_k (S_k).\T_k$ is available in the continuation.
Similarly index \lstin{k} being equal to \lstin{None} or being out of bounds of the list means 
that the message label $\ell_k$ is not present in the continuation. The function \lstin{onth} \rocqlink{todo} 
formalises this convention
in Rocq.
\begin{remark}
  Note that Rocq allows us to create types such as \lstin{ltt_send q []} which 
  don't correspond to well-formed local types as the continuation is empty.
  In our implementation we define a predicate \lstin{wfltt : ltt -> Prop} capturing that 
  all the continuations in the local type tree are non-empty. Henceforth we assume that all local types
  we mention satisfy this property.
\end{remark}
\subsection{Subtyping}
We define the subsorting relation on sorts and the subtyping relation on local type trees.
\begin{definition}[Subsorting and Subtyping] \label[definition]{def:subtyping}
  Subsorting $\subso$ is the least reflexive binary relation that satisfies $\tnat \subso \tint$. 
  Subtyping $\subtp$ is the largest relation between local type trees coinductively defined by the following rules:
  \[
  \begin{array}[t]{@{}c@{}}
    \cinferrule[]{
    }{
    \tend \subtp \tend
    }
    \enspace \rulesubend
    \quad
  \cinferrule[]{
    \forall i \in I: \qquad S'_i \subso S_i \qquad \T_i \subtp \T'_i
  }
  {
    \procinset{p}{\ell_i(S_i)}{\T_i}{i \in I \cup J} \subtp 
    \procinset{p}{\ell_i(S'_i)}{\T'_i}{i \in I}
  }
  \enspace \rulesubin
  \\\\
  \cinferrule[]{
    \forall i \in I: \qquad S_i \subso S'_i \qquad \T_i \subtp \T'_i
  }
  {
    \procoutset{p}{\ell_i(S_i)}{\T_i}{i \in I}
    \subtp
    \procoutset{p}{\ell_i(S'_i)}{\T'_i}{i \in I \cup J}
    }
  \enspace \rulesubout
  \end{array}
  \]
\end{definition}
Intutively, $\T_1 \subtp \T_2$ means that a role of type $\T_1$ can be supplied anywhere 
a role of type $\T_2$ is needed.
$\rulesubin$ captures the fact that we can supply a role that is able to receive 
more labels than specified, and $\rulesubout$ captures that we can supply a role
that has fewer labels available to send. Note the contraviance of the sorts in $\rulesubin$,
if the supertype demands the ability to receive an $\tnat$ then the subtype can 
receive $\tnat$ or $\tint$.

In Rocq, the subtyping relation \lstin{subtypeC : ltt -> ltt -> Prop} is expressed as a greatest fixpoint using the 
\lstin{Paco} library \cite{paco}, 
for details of we refer to \cite{SynchronousSubtyping}.
\subsection{Global Type Trees}
We now define global types which give a bird's eye view of the whole protocol.
As before, we work directly on infinite trees and omit the details which can be found in 
\cite{srpaper}.
$\tend$ denotes a protocol that has ended, $\GvtPair{\prt{p}}{\prt{q}}{\ell_i(\S_i).\mathbb{G}_i}_{i\in I}$
denotes a protocol where for any $i \in I$, participant $\pp$ may send a value of sort 
$S_i$ to another participant $\pq$ via message label $\ell_i$, after which the protocol continues as $\mathbb{G}_i$.
\begin{definition}[Global type trees]
  \label[definiton]{def:global_type_trees}
  We define global type trees coinductively as follows: 
  \begin{minipage}{0.47\textwidth}
  \begin{align*}
\G &::= \quad \tend 
     \SEP \GvtPair{\prt{p}}{\prt{q}}{\ell_i(\S_i).\G_i}_{i\in I}
    \end{align*}  
  \end{minipage}
    \begin{minipage}{0.50\textwidth}
    \begin{tcb}{Rocq}
    CoInductive gtt: Type :=
    | gtt_end    : gtt 
    | gtt_send   : part -> part -> list (option (sort*gtt)) -> gtt.
    \end{tcb}  
    \end{minipage}    
\end{definition}
We further define the function $\funprt(\G)$ that denotes the 
participants of the global type $\G$ as the least solution 
\footnote{Here we adopt a simplified presentation as $\funprt(\G)$ 
is actually defined by extending it from an inductively defined function on 
syntactic types, we refer to \cite{srpaper} for details.} to the following equations:
\begin{align*}
  &\funprt(\tend)=\emptyset \quad
  &\funprt(\GvtPair{\prt{p}}{\prt{q}}{\ell_i(\S_i).\G_i}_{i\in I})=
      \{\prt{p},\prt{q}\} \cup \bigcup _{i \in I} {\funprt(\G_i)}
\end{align*}
We extend the function $\funprt$ onto trees by defining $\funprt(\G)=\funprt(\mathbb{G})$
where the global type $\mathbb{G}$ corresponds to the global type tree $\G$. Technical details 
of this definition such as well-definedness can be found in \cite{srpaper,SynchronousSubtyping}. 

In Rocq $\funprt$ is captured with the 
predicate \lstin{isgPartsC : part -> gtt -> Prop}, where \lstin{isgPartsC p G} 
denotes $\prt{p} \in \funprt(\G)$.  


\subsection{Projection}
We now define coinductive projections with plain merging 
(see \cite{projsurvey} for a survey of other notions of merge). 
\begin{definition}[Projection] \label[definition]{def:projections}
    The projection of a global type tree onto a participant ${\prt{r}}$ is the largest relation $\upharpoonright_{\prt{r}}$ between global type trees and
    local type trees such that, whenever $\G\proj{r}\T$:
    \begin{itemize}
      \item ${\prt{r}} \notin \participant{\G}$ implies $\T = \tend$; \hfill {\ruleprojend}
      \item $\G = \GvtPair{\prt{p}}{\prt{r}}{\ell_i(S_i).\G_i}_{i \in I}$ implies 
      $\T = \procinset{\prt{p}}{\ell_i(\S_i)}{\T_i}{i \in I}$ and $\forall i \in I, \G\proj{r}\T_i $ \hfill {\ruleprojin}
      \item $\G = \GvtPair{\prt{r}}{\prt{q}}{\ell_i(S_i).\G_i}_{i \in I}$ implies 
      $\T = \procoutset{\prt{q}}{\ell_i(\S_i)}{\T_i}{i \in I}$ and $\forall i \in I, \G\proj{r}\T_i $ \hfill {\ruleprojout}
      \item $\G = \GvtPair{\prt{p}}{\prt{q}}{\ell_i(S_i).\G_i}_{i \in I} \text{and } {\prt{r}} \notin \{{\prt{p}},{\prt{q}}\}$ implies 
      that $\forall i \in I, \G_i\proj{r}\T $ \hfill {\ruleprojcont}
    \end{itemize}
\end{definition}

Informally, the projection of a global type tree $\G$ onto a participant $\prt{r}$
extracts a role for participant  $\prt{r}$ from the protocol whose bird's-eye view 
is given by $\G$. \ruleprojend expresses that if $\prt{r}$ is not a participant of $\G$ then
$\prt{r}$ does nothing in the protocol. \ruleprojin and \ruleprojout handle the cases where $\prt{r}$
is involved in a communication in the root of $\G$. $\ruleprojcont$ says that, if $\prt{r}$ is not
involved in the root communication of $\G$ and all continuations of $\G$ project on to the same type,
then $\G$ also projects on to that type.
In Rocq, projection is defined as a \lstin{Paco} greatest fixpoint as the relation
\lstin{projectionC : gtt -> part -> ltt -> Prop}.

We further have the following fact about projections that lets us regard it as a partial
function:
\begin{lemma}[\cite{srpaper}] \label[lemma]{lem-proj-func} If \lstin{projectionC G p T} and 
\lstin{projectionC G p T'} then \lstin{T = T'}.  
\end{lemma}
We write $\projfn{\G}{\pr}=\T$ when $\G\proj{\pr}\T$. Furthermore we will be frequently
be making assertions about subtypes of projections of a global type e.g.
$\T \subtp \projfn{\G}{\pr}$. In our Rocq implementation we define the predicate 
\lstin{issubProj : ltt -> gtt -> part -> Prop}
as a shorthand for this.
\subsection{Balancedness, Global Tree Contexts and Grafting}
We introduce an important constraint on the types of global type trees we will consider, balancedness.

\begin{definition}[Balanced Global Type Trees]\label[definition]{def-balance}
A global tree $\G$ is balanced if for any subtree $\G'$ of $\G$, there exists $k$ such that
for all $\pp \in \funprt(\G')$, $\pp$ occurs on every path from the root of $\G'$ of length at 
least $k$.
\end{definition}
We omit the technical details of this definition and the Rocq implementation, they can be found in 
\cite{SynchronousSubtyping} and \cite{srpaper}.

Balancedness is a regularity condition that imposes a notion of \textit{liveness} on the protocol
described by the global type tree. Indeed, our liveness results in \cref{sec-proc-props} 
hold only for balanced global types. Another reason for formulating balancedness is that it allows 
us to use the "grafting" technique, turning proofs by coinduction on infinite trees to proofs by induction
on finite global type tree contexts.

\begin{definition}[Global Type Tree Contexts and Grafting]\label{def:global-ctx}
  Global type tree contexts are defined inductively with the following syntax:

  \begin{minipage}{0.4\textwidth}
  \begin{align*}
    \Gcx &::= \quad \GvtPair{p}{q}{\ell_i(S_i).\Gcx_i}_{i \in I} 
   \SEP \hole_i
  \end{align*}  
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
  \begin{tcb}{Rocq}
Inductive gtth: Type :=
  | gtth_hol    : fin -> gtth
  | gtth_send   : part -> part -> list (option (sort * gtth)) -> gtth.
  \end{tcb} 
  \end{minipage}
   Given a global type tree context $\Gcx$ whose holes are in the indexing set $I$
  and a set of global types $\{\G_i\}_{i \in I}$,  the grafting $\Gcx[\G_i]_{i \in I}$ denotes 
  the global type tree obtained by substituting $\hole_i$ with $\G_i$ in $\Gcx$.

  In Rocq the indexed set $\{\G_i\}_{i \in I}$ is represented using a \lstin{list (option gtt)}.
  Grafting is expressed with the  inductive relation 
  \lstin{typ_gtth : list (option gtt) -> gtth -> gtt -> Prop}.
  \lstin{typ_gtth gs gcx gt} means that the grafting of the set of global type trees 
  \lstin{gs} onto the context \lstin{gcx} results in the tree \lstin{gt}.
  We additionally define $\funprt$ and \lstin{ishParts} on global type tree contexts analogously 
  to $\funprt$ and \lstin{isgPartsC} on trees. 
\end{definition}
A global type tree context can be thought of as the finite prefix of a global type 
tree, where holes $\hole_i$ indicate the cutoff points. Global type tree contexts
are related to global type trees with the \textit{grafting} 
operation that fills in the holes with type trees.
The following lemma relates global type tree contexts to balanced
global type trees. In particular, it allows us to turn proofs by coinduction on infinite trees 
to proofs by induction on the grafting context.
\begin{lemma}[Proper Grafting Lemma, \cite{srpaper}]\label[lemma]{lem-grafting}
If \lstin{G} is a balanced global type tree and \lstin{isgPartsC p G}, then there is 
a global type tree context \lstin{Gctx} and an option list of global type trees 
\lstin{gs} such that \lstin{typ_gtth gs Gctx G}, \lstin{\~ ishParts p Gctx} and every \lstin{Some} element of \lstin{gs}
is of shape \lstin{gtt_end}, \lstin{gtt_send p q} or \lstin{gtt_send q p}. 
\end{lemma}
If \lstin{typ_gtth gs Gctx G}, \lstin{\~ ishParts p Gctx} and every \lstin{Some} element of \lstin{gs}
is of shape \lstin{gtt_end}, \lstin{gtt_send p q} or \lstin{gtt_send q p}, then we call 
the pair \lstin{gs} and \lstin{Gctx} as the $\pp$-grafting of \lstin{G}, expressed in Rocq as
\lstin{typ_p_gtth gs Gctx p G}. When we don't care about the contents of \lstin{gs} we may just say
that \lstin{G} is \lstin{p}-grafted by \lstin{Gctx}.
\begin{remark}
  From now on, all the global type trees we will be referring to are assumed to be balanced.
  When talking about the Rocq implementation, any \lstin{G : gtt} we mention is assumed
  to satisfy the predicate \lstin{wfgC G}, expressing that \lstin{G} corresponds to some global type
  and that \lstin{G} is balanced. 
  Furthermore, we will often require that a global type is projectable onto all its participants. 
  This is captured by
  the predicate \lstin{projectableA G = forall p, exists T, projectionC G p T}. As with \lstin{wfgC}, 
  we will be assuming that all types we mention are projectable. 
\end{remark}