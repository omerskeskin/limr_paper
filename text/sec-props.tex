\section{Properties of Local Type Contexts} \label{sec-props}
We now use the LTS semantics to define some desirable properties on type contexts and their 
reduction sequences. Namely, we formulate
safety, fairness and liveness properties based on the definitions in \cite{LessIsMoreRevisited}. 
\subsection{Safety}
We start by defining the \textit{safety} property that plays an important role 
in bottom-up session type systems \cite{LessIsMore}:
\begin{definition}[Safe Type Contexts] \label[definition]{def:safety}
  We define $\safe$ coinductively as the largest set of type contexts such that whenever we have $\Gamma \in \safe$:
  \begin{align}
    \label{saferule:sendrec} \tag*{\rulesafesync} & \quad \lbltrans{\Gamma}{\lblsend{p}{q}{\ell(S)}}{} \; and \; \lbltrans{\Gamma}{\lblrec{q}{p}{\ell'(S')}} \; implies 
    \; \lbltrans{\Gamma}{\lblsync{p}{q}{\ell}}\\
    \label{saferule:reduce} \tag*{\rulesafereduce} & \quad  \lbltrans{\Gamma}{}{\Gamma'} \;implies\; \Gamma' \in \safe
  \end{align}
  We write $\safe(\Gamma)$ if \;$\Gamma \in \safe$.
\end{definition}
\begin{tcolorbox}[colback=blue!10]
Safety says that if $\pp$ and $\pq$ communicate with each other and $\pp$ requests to 
send a value using message label $\ell$, then $\pq$ should be able to receive that message label.
Furthermore, this property should be preserved under any typing context reductions. 
\end{tcolorbox}

Being a coinductive property, to show that $\safe(\Gamma)$ it suffices to give a set
$\varphi$ such that $\Gamma \in \varphi$ and $\varphi$ satisfies \rulesafesync and \rulesafereduce.
This amounts to showing that every element of $\Gamma'$ of the set of reducts of $\Gamma$,
defined
$\varphi := \{\Gamma' \; | \; \Gamma \lts{}^* \Gamma' \}$, satisfies \rulesafesync. 
We illustrate this with some examples:
\begin{example}\label{exam:safe}
   Let $\Gamma=\prt{p}:\procoutsingle{q}{\ell_0(\tint)}{\tend},\prt{q}:\procinsingle{p}{\ell_0(\tnat)}{\tend} $. 
   $\Gamma$ is not safe as as we have $\lbltrans{\Gamma}{\lblsend{p}{q}{\ell_0}}{}$ and 
   $\lbltrans{\Gamma}{\lblrec{q}{p}{\ell_0}}{}$ 
   but we don't have $\lbltrans{\Gamma}{\lblsync{p}{q}{\ell_0}}$ as $\tint \nleqslant \tnat $.
   
  Consider $\Gamma$ from Example \ref{exam:reductions}.  All the reducts satisfy \rulesafesync, hence $\Gamma$ is safe.
\end{example}

In Rocq, we define $\safe$ coinductively with Paco:
\begin{tcb}{Rocq}
Definition weak_safety (c: tctx ) :=
  forall p q s s'  k k', tctxRE (lsend p q (Some s) k) c -> tctxRE (lrecv q p (Some s') k') c -> tctxRE (lcomm p q k) c.
Inductive safe (R: tctx -> Prop): tctx -> Prop :=
  | safety_red :  forall c, weak_safety c -> (forall p q c' k, tctxR c (lcomm p q k) c' -> R c') ->  safe R c.
Definition safeC c := paco1 safe bot1 c.
\end{tcb}
\lstin{weak_safety} corresponds \rulesafesync where \lstin{tctxRE l c} is shorthand for
\lstin{exists c', tctxR c l c'}. 
In the inductive \lstin{safe}, the constructor \lstin{safety_red} corresponds to 
\rulesafereduce. Then \lstin{safeC} is defined as the greatest fixed point of \lstin{safe}.

We have that local type contexts with associated global types are always safe.
\begin{theorem}[Safety by Association \rocqlink{todo}]
  If \lstin{assoc gamma g} then \lstin{safeC gamma}.
\end{theorem}
\subsection{Fairness and Liveness}
\label{subsec-ltl}
We now focus our attention to fairness and liveness. 
We first restate the definition of fairness and liveness for 
local type context paths from \cite{LessIsMoreRevisited}.
\begin{definition}[Fair, Live Paths] \label[definition]{def-fair-live}
A local type context reduction path (also called executions or runs) is a possibly infinite sequence of transitions
$\Gamma_0 \lts{\lambda_0} \Gamma_1 \lts{\lambda_1} ..$ such that $\lambda_i$ is a synchronous transition label,
that is, of the form $\lblsync{p}{q}{\ell}$, for all $i$.

We say that a local type context reduction path $\Gamma_0 \xrightarrow{\lambda_0} \Gamma_1 \xrightarrow{\lambda_2} ..$ is fair if,
for all $n \in N: 
\Gamma_n \lts{\lblsync{\prt{p}}{\prt{q}}{\ell}}$ implies 
$\exists k,\ell'$ such that $N \ni k \ge n$ and 
$\lambda_k = \lblsync{\prt{p}}{\prt{q}}{\ell'}$, and therefore
$\Gamma_k \lts{\lblsync{\prt{p}}{\prt{q}}{\ell'}} \Gamma_{k+1}$.
We say that a path $(\Gamma_n)_{n \in N}$ is live iff, $\forall n \in N$:
\begin{enumerate}
  \item $\forall n \in N: \Gamma_n \lts{\lblsend{\prt{p}}{\prt{q}}{\ell(S)}}$ implies $\exists k,\ell'$ such that $N \ni k \ge n$ and $\Gamma_k \lts{\lblsync{\prt{p}}{\prt{q}}{\ell'}} \Gamma_{k+1}$
  \item $\forall n \in N: \Gamma_n \lts{\lblrec{\prt{q}}{\prt{p}}{\ell(S)}}$ implies $\exists k,\ell'$ such that $N \ni k \ge n$ and $\Gamma_k \lts{\lblsync{\prt{p}}{\prt{q}}{\ell'}} \Gamma_{k+1}$
\end{enumerate}
\end{definition}
\begin{definition}[Live Local Type Context]\label[definition]{def-live-ctx}
  A local type context $\Gamma$ is live if whenever $\Gamma \rdc^{*} \Gamma'$,
  every fair path starting from $\Gamma'$ 
  is also live.
\end{definition}
\begin{tcolorbox}[colback=blue!10]
In general, fairness assumptions are used so that only the reduction sequences that are
"well-behaved" in some sense are considered when formulating other properties \cite{fairness}. 
We define fairness such that, in a fair path, whenever a synchronous transition $\lblsync{p}{q}{\ell}$
is enabled, a communication between $\pp$ and $\pq$ is eventually executed.  
Then live paths are defined to be paths such that whenever $\pp$ attempts to send to $\pq$ \textit{or} 
$\pq$ attempts to receive from $\pp$, eventually a $\pp$ to $\pq$ communication takes place.
Informally, this means that every communication request is eventually answered.
Live typing contexts are then defined to be the $\Gamma$ such that whenever 
$\Gamma$ can evolve (in possibly multiple steps) into $\Gamma'$, 
all fair paths that start from  $\Gamma'$ are also live.  
\end{tcolorbox}


\begin{example}\label[examples]{exam:live}
  Consider the contexts $\Gamma, \Gamma'$ and  $\Gamma_\tend$ from 
  Example \ref{exam:reductions}. One possible reduction path is 
  $\Gamma \lts{\lblsync{\prt{p}}{\prt{q}}{\ell_0}} \Gamma \lts{\lblsync{\prt{p}}{\prt{q}}{\ell_0}} \dots$. 
  Denote this path as $(\Gamma_n)_{n \in \mathbb{N}}$, where $\Gamma_n = \Gamma$ for all $n \in \mathbb{N}$. 
We have $\forall n, \Gamma_n \lts{\lblsync{\prt{p}}{\prt{q}}{\ell_0}}$ and 
  $\Gamma_n \lts{\lblsync{\prt{p}}{\prt{q}}{\ell_1}}$ as the only possible synchronised reductions from $\Gamma_n$.
  Accordingly, we also have $\forall n, \Gamma_n \lts{\lblsync{\prt{p}}{\prt{q}}{\ell_0}} \Gamma_{n+1}$ in the path so this path is fair.
  However, this path is not live as we have $\Gamma_1 \lts{\lblrec{\prt{r}}{\prt{q}}{\ell_2(\tint)}}$ but there is no $n, 
  \ell'$ with $\Gamma_n \lts{\lblsync{\prt{q}}{\prt{r}}{\ell'}} \Gamma_{n+1}$ in the path.
  Consequently, $\Gamma$ is not a live type context.
  %FIX

  Now consider the reduction path $\Gamma \lts{\lblsync{\prt{p}}{\prt{q}}{\ell_0}} \Gamma 
  \lts{\lblsync{p}{q}{\ell_0}}  \Gamma' \lts{\lblsync{\prt{q}}{\prt{r}}{\ell_2}} 
  \Gamma_\tend$. 
  This path is fair and live as it contains the $\lblsync{\prt{q}}{\prt{r}}{}$ transition 
  from the counterexample above.   
\end{example}
\cref{def-fair-live} , while intuitive, is not really convenient for a Rocq formalisation due to 
the existential statements it contains. It would be ideal if these properties could
be expressed as a least or greatest fixed point, which could then be formalised via Rocq's 
inductive or (via Paco) coinductive  types. 
To achieve this, we recast fairness and liveness for local type context paths 
in Linear Temporal Logic (LTL) 
\cite{pnueli1977temporal}. 
The LTL operators \textit{eventually} ($\lozenge$) and \textit{always} ($\square$) can be characterised as least and greatest fixed points using their expansion laws \cite[Chapter 5.14]{baier}.
Hence they can be implemented in Rocq as the inductive type \lstin{eventually} \rocqlink{todo} and the coinductive type 
\lstin{alwaysCG} \rocqlink{todo}. We can further represent reduction paths
as \textit{cosequences}, or \textit{streams}. Then the Rocq definition of \cref{def-fair-live} amounts to the following \rocqlink{todo}:

\begin{minipage}{0.4\textwidth}
\begin{tcb}{Rocq}
CoInductive coseq (A: Type): Type :=
  | conil : coseq A
  | cocons: A -> coseq A -> coseq A.
Notation local_path := (coseq (tctx*option label)).
\end{tcb}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{tcb}{Rocq}
Definition fair_path_local_inner (pt: local_path): Prop :=
  forall p q n, to_path_prop (tctxRE (lcomm p q n)) False pt ->  eventually (headComm p q) pt.
Definition fair_path := alwaysCG fair_path_local_inner.
Definition live_path_inner (pt: local_path) : Prop := forall p q s n, 
(to_path_prop (tctxRE (lsend p q (Some s) n)) False pt -> eventually (headComm p q) pt) /\
(to_path_prop (tctxRE (lrecv p q (Some s) n)) False pt -> eventually (headComm q p) pt).
Definition live_path := alwaysCG live_path_inner.
\end{tcb}  
\end{minipage}

With these definitions we can now prove that local type contexts associated with a global type are live,
which is the most involved of the results mechanised in this work.
\begin{remark}
  We once again emphasise that all global types mentioned are assumed to be balanced (\cref{def-balance}).
  Indeed association with non-balanced global types doesn't guarantee liveness. 
  As an example, consider $\Gamma$ from Example \ref{exam:reductions}, which is associated with 
  $\G$ from Example \ref{exam:assoc}. Yet we have shown in Example \ref{exam:live} that $\Gamma$
  is not a live type context. This is not surprising as $\G$ is not balanced.  
\end{remark}
\begin{theorem}[Liveness by Association \rocqlink{todo}]\label{theo-ctx-live}
If \lstin{assoc gamma g} then \lstin{gamma} is live.  
\end{theorem}
\begin{proof} (Simplified, Outline) Our proof proceeds in two steps. 
First, we prove that the typing context obtained by direct projections 
\footnote{Note that the actual Rocq proof defines an equivalent "enabledness" predicate on 
global types instead of working with direct projections. 
The outline given here is a slightly simplified presentation.} of \lstin{g},
that is, \lstin{gamma_proj = } $\{ \pp_i : \G \proj{\pp_i} \SEP \pp_i \in \participant{\G}\}$, is live. 
We then leverage
\cref{theo-completeness} to show that if \lstin{gamma_proj} is live, so is \lstin{gamma}. 

Suppose  \lstin{gamma_proj} $\lts{\lblsend{p}{q}{\ell(S)}}$ (the case for the receive is similar and omitted), 
and \lstin{xs} is a fair local type context reduction path beginning with \lstin{gamma_proj}.
To show that \lstin{xs} is live we need to show the 
existence of a  $\lblsync{p}{q}{\ell}$ transition in \lstin{xs}. 
We achieve this by taking the height of the \lstin{p}-grafting of the 
global type associated with the head of \lstin{xs} as our induction invariant.
We show (\rocqlink{todo}, \rocqlink{todo}, \rocqlink{todo}) that this invariant keeps decreasing until a $\lblsync{p}{q}{\ell}$ transition is enabled on the path,
at which point our fairness assumption forces that transition to fire \rocqlink{todo}. 

In the second step of the proof we extend association on to paths to get, for each local type context reduction path 
\lstin{xs} that begins with \lstin{gamma}, another local type context reduction path \lstin{ys} beginning with \lstin{gamma_proj}
such that the elements of \lstin{xs} are subtypes (subtyping on contexts defined pointwise) 
of the corresponding elements of \lstin{ys}. This is obtained from \cref{theo-completeness}, however the statement of
\cref{theo-completeness} is implemented as an \lstin{exists} statement
that lives in \lstin{Prop}, hence we need to use the \lstin{constructive_indefinite_description} axiom
to construct a \lstin{CoFixpoint} returning the desired cosequence \lstin{ys}. The proof then follows by the definition of
subtyping (\cref{def:subtyping}).
\end{proof}