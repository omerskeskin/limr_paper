\section{The Session Calculus}
\label{sec-procs}
We introduce the simple synchronous session calculus that our type system will be used on. 
\newcommand{\PT}{\mathsf P}
\newcommand{\Xv}{\ensuremath{{\textbf{X}}}}
\newcommand{\ST}{{\mathsf S}}
\newcommand{\QT}{{\mathsf Q}}
\newcommand{\RT}{{\mathsf R}}

\subsection{Processes and Sessions}
\begin{definition}[Expressions and Processes]
  \label[definition]{def:processes}
  We define processes as follows: 
  \begin{align*}
    \PT ::= \prt{p}!\ell(\kf{e}).\PT \SEP \sum_{i \in I}
\prt{p}?\ell_i(x_i).\PT_i \SEP \cond{\kf{e}}{\PT}{\PT} \SEP \mu \Xv.\PT \SEP \Xv \SEP \textbf{0}
    \end{align*}
    where \kf{e} is an expression that can be a variable, a value such as \texttt{true}, $0$ or $-3$, 
    or a term built from expressions by applying the operators \texttt{succ}, \texttt{neg}, $\neg$, 
    non-deterministic choice $\sendsign$ and $>$. 
\end{definition}
$\prt{p}!\ell(\kf{e}).\PT$ is a process that sends the value of expression $\kf{e}$ 
with label $\ell$ to participant $\pp$, and continues with process $\PT$.
$\sum_{i \in I}
\prt{p}?\ell_i(x_i).\PT_i$ is a process that may receive a value from $\pp$ with any label  
$\ell_i$ where $i\in I$, binding the result to $x_i$ and continuing with $\PT_i$, depending on which $\ell_i$
the value was received from. $\Xv$ is a recursion variable, $\mu \Xv.\PT$ is a recursive process,
$\cond{\kf{e}}{\PT}{\PT}$ is a conditional and $\textbf{0}$ is a terminated process.

Processes can be composed in parallel into sessions.
\begin{definition}[Multiparty Sessions]\label[definition]{def:sessions}
  Multiparty sessions are defined as follows.
    \[
    \M \;::=\;%
    {\prt{p}} \triangleleft \PT \quad \SEP \quad(\M  \mid \M)
    \quad \SEP \quad \mathcal{O}
  \]
\end{definition}
${\prt{p}} \triangleleft \PT$ denotes that participant $\pp$ is running the process $\PT$,
$\mid$ indicates parallel compositon. We write $\displaystyle  \prod_{i \in I}^{} \pp_i \triangleleft \PT_i$
to denote the session formed by $\pp_i$ running $\PT_i$ in parallel for all $i \in I$. 
$\mathcal{O}$
is an empty session with no participants, that is, the unit of parallel composition.
%\begin{remark}
%Note that $\mathcal{O}$ is different than
%$\pp \triangleleft \textbf{0}$ as $\pp$ is a participant in the latter but not the former. 
%This differs from previous work, e.g. in \cite{SynchronousSubtyping} the unit of 
%parallel composition is 
%$\pp \triangleleft \textbf{0}$ while in \cite{srpaper} there is no unit. 
%The unitless appproach of \cite{srpaper} results in a lot of repetition in the code, 
%for an example see their definition of \lstin{unfoldP} which contains two of every constructor:
%one for when the session is composed of exactly two processes, and one for when it's composed of three or more.
%Therefore we chose to add an unit element to parallel composition. However, we didn't make 
%that unit $\pp \triangleleft \textbf{0}$ in order to reuse some of the lemmas from \cite{srpaper}
%that use the fact that structural congruence preserves participants.
%\end{remark} 
In Rocq processes and sessions are defined with the inductive types \lstin{process} \rocqlink{todo} and \lstin{session} \rocqlink{todo}.
\begin{minipage}{0.45\textwidth}
\begin{tcb}{Rocq}
Inductive process : Type := 
  | p_send : part -> label -> expr -> process -> process
  | p_recv : part -> list(option process) -> process 
  | p_ite : expr -> process -> process -> process
  | p_rec : process -> process
  | p_var : nat -> process
  | p_inact : process.  
\end{tcb}
\end{minipage}
\begin{minipage}{0.45\textwidth}
  \begin{tcb}{Rocq}
  Inductive session: Type :=
  | s_ind : part   -> process -> session
  | s_par : session -> session -> session
  | s_zero : session.
Notation "p '<--' P"   :=  (s_ind p P) (at level 50, no associativity).
Notation "s1 '|||' s2" :=  (s_par s1 s2) (at level 50, no associativity).
\end{tcb}
\end{minipage}

\subsection{Structural Congruence and Operational Semantics}
We define a structural congruence relation $\equiv$ on sessions which expresses the commutativity, associativity and 
unit of the parallel composition operator.

\begin{table}[h]
{\footnotesize
\[
\begin{array}{@{}l@{}}
  \inferrule[\rulename{sc-sym}]
  {}
  {\pp \triangleleft \PT  \mid \pq \triangleleft \QT  \equiv \pq \triangleleft \QT \mid \pp \triangleleft \PT} 
  \qquad
  \inferrule[\rulename{sc-assoc}]
  {}
  {(\pp \triangleleft \PT  \mid \pq \triangleleft \QT) \mid \pr \triangleleft \RT  
  \equiv \pp \triangleleft \PT  \mid (\pq \triangleleft \QT \mid \pr \triangleleft \RT)} 
  \qquad
  \inferrule[\rulename{sc-o}]
  {}
  {\pp \triangleleft \PT  \mid \mathcal{O}  
  \equiv \pp \triangleleft \PT } 
\end{array}
\]}
\caption{Structural Congruence over Sessions}
\label{tbl:scong}
\end{table}
We omit the semantics for expressions, they are standard and can be found in e.g. \cite{SynchronousSubtyping}. 
We now give the operational semantics for sessions by the means of a labelled transition system.
We use labelled \textit{reactive} semantics \cite{fairnesslock,castellani_reversible_2019}
which doesn't contain explicit silent $\tau$ actions for internal reductions (that is, evaluation of if expressions
and unfolding of recursion) while still considering $\beta$ reductions
up to those internal reductions by using an unfolding relation. 
This stands in contrast to the more standard semantics used in \cite{srpaper,SynchronousSubtyping,fairnesslock}.
For the advantages of our approach see \cref{remark-reactive-justif}.
\label{def-sess-semantics}

In reactive semantics silent transitions are captured by an \textit{unfolding} relation $(\Rrightarrow)$,
and $\beta$ reductions are defined up to this unfolding (\cref{tbl:unf}).
\begin{table}[h]
{\footnotesize
\[
\begin{array}{@{}l@{}}
    \inferrule[\rulename{Unf-struct}]
  {\M \equiv \N}
  {\M \Rrightarrow \N}
  \quad
  \inferrule[\rulename{Unf-rec}]
  {}
  {\pp \triangleleft \mu \Xv.\PT \mid \N \ \ 
  \Rrightarrow
    \pp \triangleleft \PT[\mu \Xv.\PT / \Xv] \ \mid \ \N}  
  \quad
    \inferrule[\rulename{Unf-condt}]
  {e \downarrow \text{true}}
  {\pp \triangleleft \text{ if } e \text{ then } \PT \text{ else } \QT \ \mid \ \N \ \ 
  \Rrightarrow \ \
    \pp \triangleleft \PT \ \mid \ \N}    
      \\[5mm]
        \inferrule[\rulename{Unf-condf}]
  {e \downarrow \text{false}}
  {\pp \triangleleft \text{ if } e \text{ then } \PT \text{ else } \QT \ \mid \ \N \ \ 
  \Rrightarrow \ \
    \pp \triangleleft \QT \ \mid \ \N}  
  \quad
    \inferrule[\rulename{Unf-trans}]
  {\M \Rrightarrow \M' \quad \M' \Rrightarrow \N }
  {\M \Rrightarrow \N}  
\end{array}
\]}
\caption{Unfolding of Sessions}
\label{tbl:unf}
\end{table}

$\M \Rrightarrow \N$ means that $\M$ can transition to $\N$ through some internal actions, that is, a reduction that doesn't involve a communication. 
We say that $\M$ \textit{unfolds} to $\N$. 
In Rocq it's captured by the predicate \lstin{unfoldP : session -> session -> Prop} \rocqlink{todo}.
\begin{table}[h]
{\footnotesize
\[
\begin{array}{@{}l@{}}
    \inferrule[\rulename{R-comm}]
  {j\in I \quad e \downarrow v}
  {\pp \triangleleft \sum^{}_{i\in I} \tin\pq{\ell_i}{x_i}.\PT_i \ \mid \  \pq \triangleleft \tout{\pp}{\ell_j}{\kf{e}}.\QT \ \mid \ \N \ \ 
  \xrightarrow{(\pp,\pq)\ell_j} \ \ 
    \pp \triangleleft \PT_j[v/x_j] \ \mid \ \pq \triangleleft \QT \ \mid \ \N}
    \\[10mm]
    \inferrule[\rulename{R-unfold}]
  {\M \Rrightarrow \M' \quad \M' \lts{\lambda} \N' \quad \N' \Rrightarrow \N}
  {\M \lts{\lambda} \N}
    \\[10mm]
\end{array}
\]}
\caption{Reactive Semantics of Sessions}
\label{tbl:srr-react}
\end{table}

\cref{tbl:srr-react} illustrates the rules for communicating transitons. 
\rulename{R-comm} captures communications between processes, and \rulename{R-unfold} lets us consider reductions up to
unfoldings. In Rocq, \lstin{betaP_lbl M lambda M'} \rocqlink{todo} denotes 
$\M \lts{\lambda} \M'$. We write $\M \lts{} \M'$ if $\M \lts{\lambda} \M'$
for some $\lambda$, which is written \lstin{betaP M M'} in Rocq.
We write $\lts{}^*$ to denote the reflexive transitive closure of
$\lts{}$, which is called \lstin{betaRtc} \rocqlink{todo} in Rocq. 